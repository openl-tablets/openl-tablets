package org.openl.rules.datatype.binding;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

import net.sf.cglib.core.ReflectUtils;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.CodeVisitor;
import org.objectweb.asm.Constants;
import org.objectweb.asm.Type;
import org.openl.util.StringTool;
import org.openl.util.generation.JavaClassGeneratorHelper;

/**
 * Generates byte code for simple java bean.
 * 
 * @author DLiauchuk
 *
 */
public class SimpleBeanByteCodeGenerator {
    
    private static final String JAVA_LANG_OBJECT = "java/lang/Object";

    private final Log LOG = LogFactory.getLog(SimpleBeanByteCodeGenerator.class);
    
    private String beanName;
    private Map<String, FieldType> beanFields;
    private byte[] generatedByteCode;
    
    /**
     * 
     * @param beanName name of the generated class, with namespace (e.g. <code>my.test.TestClass</code>)
     * @param beanFields map of fields, field name as a key, and type as value.
     */
    public SimpleBeanByteCodeGenerator(String beanName, Map<String, FieldType> beanFields) {
        this.beanName = beanName;
        this.beanFields = new HashMap<String, FieldType>(beanFields);
    }
    
    /**
     *  
     * @return generated byte code of the simple bean
     */
    public byte[] generateClassByteCode() {
        String beanNameWithPackage = JavaClassGeneratorHelper.replaceCommas(beanName);
        
        ClassWriter classWriter = new ClassWriter(false);

        writeClassDescription(beanNameWithPackage, classWriter);

        writeFields(classWriter);
        
        writeDefaultConstructor(classWriter);
        
        writeGettersAndSetters(beanNameWithPackage, classWriter);
        
        generatedByteCode = classWriter.toByteArray();
        
        //writeBytesToFile(generatedByteCode);
        
        return generatedByteCode;
    }
    
    /**
     * 
     * @return <code>Class<?></code> object of the generated bean class.
     */
    public Class<?> generateAndLoadBeanClass() {
        if (generatedByteCode != null) {
            return loadClass(generatedByteCode);
        } else {
            return loadClass(generateClassByteCode());
        }
    }
    
    /**
     * Writes getters and setters to the generated bean class.
     * 
     * @param beanNameWithPackage
     * @param classWriter
     */
    private void writeGettersAndSetters(String beanNameWithPackage, ClassWriter classWriter) {
        for(Map.Entry<String, FieldType> field : beanFields.entrySet()) {
            generateGetter(beanNameWithPackage, classWriter, field);
            generateSetter(beanNameWithPackage, classWriter, field);
        }
    }

    private void writeDefaultConstructor(ClassWriter classWriter) {
        CodeVisitor codeVisitor;
        // creates a MethodWriter for the (implicit) constructor
        codeVisitor = classWriter.visitMethod(Constants.ACC_PUBLIC, "<init>", "()V", null, null);
        // pushes the 'this' variable
        codeVisitor.visitVarInsn(Constants.ALOAD, 0);
        // invokes the super class constructor
        codeVisitor.visitMethodInsn(Constants.INVOKESPECIAL, JAVA_LANG_OBJECT, "<init>", "()V");
        codeVisitor.visitInsn(Constants.RETURN);
        // this code uses a maximum of one stack element and one local variable
        codeVisitor.visitMaxs(1, 1);
    }
    
    /**
     * Write fields declarations to the generated bean class.
     * 
     * @param classWriter
     */
    private void writeFields(ClassWriter classWriter) {
        for (Map.Entry<String,  FieldType> field : beanFields.entrySet()) {
          String fieldTypeName = getJavaType(field.getValue());
          classWriter.visitField(Constants.ACC_PRIVATE, field.getKey(), fieldTypeName, null, null);
        }
    }
    
    /**
     * Write the description of generating class.
     * 
     * @param beanNameWithPackage name of the class with package, symbol '/' is used as separator<br> 
     * (e.g. <code>my/test/TestClass</code>) 
     * @param classWriter
     */
    private void writeClassDescription(String beanNameWithPackage, ClassWriter classWriter) {
        String sourceFileName = JavaClassGeneratorHelper.getClassFileName((beanNameWithPackage));
        classWriter.visit(Constants.V1_5, Constants.ACC_PUBLIC + Constants.ACC_SUPER, beanNameWithPackage, JAVA_LANG_OBJECT, 
            null, sourceFileName);
    }

    private void writeBytesToFile(byte[] byteArray) {
        String strFilePath = String.format("D://%s.class", JavaClassGeneratorHelper.getShortClassName(beanName));
        try {
            FileOutputStream fos = new FileOutputStream(strFilePath);
            fos.write(byteArray);
            fos.close();
        } catch(FileNotFoundException ex) {
            LOG.error(this, ex);
        } catch(IOException ioe){
            LOG.error(this, ioe);
        }
    }
    
    /**
     * Generates getter for the field.
     * 
     * @param beanNameWithPackage
     * @param classWriter
     * @param field
     */
    private void generateGetter(String beanNameWithPackage, ClassWriter classWriter, Map.Entry<String, FieldType> field) {
        CodeVisitor codeVisitor;
        String fieldName = field.getKey();
        FieldType fieldType = field.getValue();
        String getterName = StringTool.getGetterName(fieldName);
        
        codeVisitor = classWriter.visitMethod(Constants.ACC_PUBLIC,  getterName, String.format("()%s",
            getJavaType(fieldType)), null, null);
        codeVisitor.visitVarInsn(Constants.ALOAD, 0);
        codeVisitor.visitFieldInsn(Constants.GETFIELD, beanNameWithPackage, fieldName, getJavaType(fieldType));
        codeVisitor.visitInsn(getConstantForReturn(fieldType));
        
        // long and double types are the biggest ones, so they use a maximum of two stack  
        // elements and one local variable for getter method.
        if (long.class.equals(fieldType.getType()) || double.class.equals(fieldType.getType())) {
            codeVisitor.visitMaxs(2, 1);
        } else {
            codeVisitor.visitMaxs(1, 1);
        }
    }
    
    private int getConstantForReturn(FieldType fieldType) {
        Class<?> retClass = fieldType.getType();
        if (retClass != null) {
            return getConstantForReturn(retClass);
        } else {
            return Constants.ARETURN;
        }
    }
    
    /**
     * Returns the constant for return type. Each primitive type has its constant.
     * 
     * @param fieldClass
     * @return
     */
    private int getConstantForReturn(Class<?> fieldClass) {
        if (fieldClass.equals(int.class) || fieldClass.equals(short.class) || fieldClass.equals(boolean.class)
                || fieldClass.equals(char.class) || fieldClass.equals(byte.class)) {
            return Constants.IRETURN;
        } else if (fieldClass.equals(long.class)) {
            return Constants.LRETURN;
        } else if (fieldClass.equals(double.class)) {
            return Constants.DRETURN;
        } else if (fieldClass.equals(float.class)) {
            return Constants.FRETURN;
        } else if (fieldClass instanceof Object) {
            return Constants.ARETURN;
        }
        return 0;
    }
    
    /**
     * Generates setter for the field.
     * 
     * @param beanNameWithPackage
     * @param classWriter
     * @param field
     */
    private void generateSetter(String beanNameWithPackage, ClassWriter classWriter, Map.Entry<String, FieldType> field) {
        CodeVisitor codeVisitor;
        String fieldName = field.getKey();
        FieldType fieldType = field.getValue();        
        String setterName = StringTool.getSetterName(field.getKey());
        
        codeVisitor = classWriter.visitMethod(Constants.ACC_PUBLIC,  setterName, String.format("(%s)V", 
            getJavaType(fieldType)), null, null);
        codeVisitor.visitVarInsn(Constants.ALOAD, 0);
        codeVisitor.visitVarInsn(getConstantForVarInsn(fieldType), 1);
        
        codeVisitor.visitFieldInsn(Constants.PUTFIELD, beanNameWithPackage, fieldName, getJavaType(fieldType));
        codeVisitor.visitInsn(Constants.RETURN);
        
        // long and double types are the biggest ones, so they use a maximum of three stack  
        // elements and three local variables for setter method.
        if (long.class.equals(fieldType.getType()) || double.class.equals(fieldType.getType())) {
            codeVisitor.visitMaxs(3, 3);
        } else {
            codeVisitor.visitMaxs(2, 2);
        }
    }
 
    private int getConstantForVarInsn(FieldType fieldType) {
        Class<?> retClass = fieldType.getType();
        if (retClass != null) {
            return getConstantForVarInsn(retClass);
        } else {
            return Constants.ALOAD;
        }
    }

    private int getConstantForVarInsn(Class<?> fieldClass) {
        if (fieldClass.equals(int.class) || fieldClass.equals(short.class) || fieldClass.equals(boolean.class)
                || fieldClass.equals(char.class) || fieldClass.equals(byte.class)) {
            return Constants.ILOAD;        
        } else if (fieldClass.equals(long.class)) {
            return Constants.LLOAD;
        } else if (fieldClass.equals(double.class)) {
            return Constants.DLOAD;
        } else if (fieldClass.equals(float.class)) {
            return Constants.FLOAD;
        } else if (fieldClass instanceof Object) {
            return Constants.ALOAD;
        }
        return 0;
    }   
    
    /**
     * Return loaded to classpath class object
     * 
     * @param byteCode generated byteCode
     * 
     * @return <code>Class<?></code> descriptor for given byteCode
     */
    private Class<?> loadClass(byte[] byteCode) {
        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
        try {
            // try to define bean class in classloader, and return
            // class object.
            return ReflectUtils.defineClass(beanName, byteCode, classLoader);
        } catch (Exception ex) {
            LOG.debug(this, ex);
            try {
                // if defining fails, when this class already exists in
                // classloader,
                // try to return class object previosly loaded.
                return Class.forName(beanName, true, classLoader);
            } catch (Exception e) {
                LOG.error(this, e);
            } catch (VerifyError exc) {
                LOG.error(this, exc);
            }
        }

        return null;
    }
    
    /**
     * Returns the Java type corresponding to the given class.
     * 
     * @param fieldClass
     * @return the Java type corresponding to the given class.
     */
    private String getJavaType(Class<?> fieldClass) {
        return String.valueOf(Type.getType(fieldClass));
    }
    
    /**
     * Gets Java type corresponding to the given field type.
     * 
     * @param fieldType
     * @return Java type corresponding to the given field type. (e.g. <code>Lmy/test/TestClass;</code>)
     */
    private String getJavaType(FieldType fieldType) {
        Class<?> fieldClass = fieldType.getType();
        if (fieldClass != null) {
            return getJavaType(fieldClass);
        } else {
            return JavaClassGeneratorHelper.getJavaType(fieldType.getTypeName());
        }
    }
}
