package org.openl.rules.lang.xls.binding;

import org.openl.OpenL;
import org.openl.binding.IBindingContext;
import org.openl.binding.IBindingContextDelegator;
import org.openl.binding.IMemberBoundNode;
import org.openl.engine.OpenLManager;
import org.openl.rules.binding.RulesModuleBindingContext;
import org.openl.rules.data.DuplicatedTableException;
import org.openl.rules.lang.xls.syntax.TableSyntaxNode;
import org.openl.rules.table.IGridTable;
import org.openl.rules.table.openl.GridCellSourceCodeModule;
import org.openl.rules.table.properties.ITableProperties;
import org.openl.rules.table.properties.def.TablePropertyDefinitionUtils;
import org.openl.source.IOpenSourceCodeModule;
import org.openl.source.impl.SubTextSourceCodeModule;
import org.openl.types.IOpenClass;
import org.openl.types.impl.OpenMethodHeader;

/**
 * Node binder for executable nodes with check for duplicates.
 * 
 * @author PUdalau
 */
public abstract class AExecutableNodeBinder extends AXlsTableBinder {

    @Override
    public IMemberBoundNode preBind(TableSyntaxNode tsn, OpenL openl, IBindingContext cxt, XlsModuleOpenClass module)
            throws Exception {
        OpenMethodHeader header = createHeader(tsn, openl, cxt);
        header.setDeclaringClass(module);

        checkForDuplicates(tsn, (RulesModuleBindingContext) cxt, header);
        return createNode(tsn, openl, header, module);
    }

    protected OpenMethodHeader createHeader(TableSyntaxNode tsn, OpenL openl, IBindingContext cxt) throws Exception {
        IGridTable table = tsn.getTable().getGridTable();
        IOpenSourceCodeModule src = new GridCellSourceCodeModule(table);
        OpenMethodHeader header = (OpenMethodHeader) OpenLManager.makeMethodHeader(openl, new SubTextSourceCodeModule(
                src, tsn.getHeader().getHeaderToken().getIdentifier().length()), (IBindingContextDelegator) cxt);
        return header;
    }

    private void checkForDuplicates(TableSyntaxNode tsn, RulesModuleBindingContext cxt, OpenMethodHeader header)
            throws DuplicatedTableException {
        String key = makeKey(tsn, header);

        if (!cxt.isTableSyntaxNodeExist(key)) {
            cxt.registerTableSyntaxNode(key, tsn);
        } else {
            throw new DuplicatedTableException(tsn.getDisplayName(), cxt.getTableSyntaxNode(key), tsn);
        }
    }

    /**
     * @param tsn TableSyntaxNode for key generation.
     * @param header Header for executable tsn with its signature.
     * @return Key to check uniqueness of tsn(generated by table name, arg types, dimensional properties and version).
     */
    private String makeKey(TableSyntaxNode tsn, OpenMethodHeader header) {
        StringBuilder sb = new StringBuilder();
        sb.append(header.getName());

        // arg types
        sb.append("(");
        boolean first = true;
        for (IOpenClass c : header.getSignature().getParameterTypes()) {
            if (!first) {
                sb.append(",");
            }
            sb.append(c.getName());
            first = false;
        }
        sb.append(")");

        // dimensional properties and version
        sb.append("[");
        ITableProperties tableProperties = tsn.getTableProperties();
        for (String property : TablePropertyDefinitionUtils.getDimensionalTableProperties()) {
            sb.append(tableProperties.getPropertyValue(property));
            sb.append(',');
        }
        sb.append(tableProperties.getVersion());
        sb.append("]");

        return sb.toString();
    }

    protected abstract IMemberBoundNode createNode(TableSyntaxNode tsn, OpenL openl, OpenMethodHeader header,
            XlsModuleOpenClass module);
}
