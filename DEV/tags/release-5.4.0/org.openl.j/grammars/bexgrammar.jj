options {
// see CharStream.html in doc for JavaCC
// input streams were edited manually!
    UNICODE_INPUT = true;
// TODO: JAVA_UNICODE_ESCAPE = true;

    COMMON_TOKEN_ACTION = true;

    LOOKAHEAD=1; 
    STATIC=false;
}


PARSER_BEGIN(BExGrammar)

package org.openl.grammars.bexgrammar;

//import org.openl.syntax.*;
//import org.openl.syntax.impl.*;
//import org.openl.util.text.*;
//import java.util.*;

public class BExGrammar extends org.openl.syntax.impl.JavaCC30Grammar
{

public BExGrammar()
{
	this(new java.io.StringReader(""));		
}


protected org.openl.util.text.IPosition begin(Token t)
{
  return pos(t.beginLine, t.beginColumn);
}

protected org.openl.util.text.IPosition end(Token t)
{
  return pos(t.endLine, t.endColumn);
}

protected org.openl.util.text.TextInterval pos(Token t)
{
  return t == null ? null : new org.openl.util.text.TextInterval(begin(t), end(t));
}

protected org.openl.util.text.TextInterval pos(Token t1, Token t2)
{
  return new org.openl.util.text.TextInterval(begin(t1), end(t2));
}

	protected org.openl.util.text.TextInterval pos(
		String lexError,
		Token t,
		StringBuffer resMessage)
	{
		String prefix = "Lexical error at line ";

		if (!lexError.startsWith(prefix))
		{
			resMessage.append(lexError);
			return pos(t);
		}

		lexError = lexError.substring(prefix.length());

		int i = 0;
		int line = 0;
		int col = 0;

		while (Character.isDigit(lexError.charAt(i)))
		{
			line = line * 10 + lexError.charAt(i) - '0';
			++i;
		}

		String prefix2 = ", column ";
		i += prefix2.length();

		while (Character.isDigit(lexError.charAt(i)))
		{
			col = col * 10 + lexError.charAt(i) - '0';
			++i;
		}

		resMessage.append(lexError.substring(i + 2));

		return new org.openl.util.text.TextInterval(
			pos(line, col),
			pos(line, col));

	}

public void parseTopNode(String type)
{
	try
	{
		if (type.equals("method.body"))
	        parseTopNodeInternal();
	    else if (type.equals("method.header"))
	       MethodHeader(); 
	    else if (type.equals("module"))
	       parseModuleInternal(); 
        else if (type.equals("type"))
                Type();

        else if (type.equals("range.literal.real"))
                RangeLiteralFloat();
        else if (type.equals("range.literal"))
                RangeLiteral();
	}
	catch (ParseException pe)
	{
		//pe.printStackTrace();
		//throw pe;
		stb.addError(
			new org.openl.syntax.impl.SyntaxError(
				pos(pe.currentToken),
				pe.getMessage(),
				null,
				stb.getModule()));
	}
	catch (TokenMgrError err)
	{
		StringBuffer buf = new StringBuffer();
		org.openl.util.text.TextInterval loc =
			pos(err.getMessage(), token, buf);
	
		stb.addError(
			new org.openl.syntax.impl.SyntaxError(loc, buf.toString(), null, stb.getModule()));
	}
	catch (Exception e)
	{
		stb.addError(new org.openl.syntax.impl.SyntaxError(pos(token), "", e, stb.getModule()));
	}
	catch (Throwable t)
	{
		stb.addError(new org.openl.syntax.impl.SyntaxError(pos(token), "", t, stb.getModule()));
	}
}

} //EOF JGrammar

PARSER_END(BExGrammar)

TOKEN_MGR_DECLS:
{
  // CommonTokenAction: use the begins/ends fields added to the Jack
  // CharStream class to set corresponding fields in each Token (which was
  // also extended with new fields). By default Jack doesn't supply absolute
  // offsets, just line/column offsets
  void CommonTokenAction(Token t)
  {
//    t.beginsAt = input_stream.beginOffset;
//    t.endsAt = input_stream.endOffset;
//    throw new RuntimeException("Define CommonTokenAction");
/*
    org.openl.util.Log.debug(
      "Token = <"
        + t.image
        + "> "
        + "("
        + t.beginLine
        + ","
        + t.beginColumn
        + ")-("
        + t.endLine
        + ","
        + t.endColumn
        + ")"
        + " "
        + t.kind
        + " = "
        + JGrammarConstants.tokenImage[t.kind]);
*/

  } // CommonTokenAction
} // TOKEN_MGR_DECLS

SKIP :
{
  " "
  | "\r"
  | "\t"
  | "\n"
  | "\f"
}


/*
TOKEN :
{
 < EOL: "\n" >
}
*/

/* special words */

TOKEN :
{
  < OR: "or" >
//| < BOOLEAN: "boolean" >
| < AND: "and" >
| < NOT: "not" >
  
}


/* JAVA RESERVED WORDS AND LITERALS */

TOKEN :
{
  < ABSTRACT: "abstract" >
//| < BOOLEAN: "boolean" >
| < BREAK: "break" >
//| < BYTE: "byte" >
| < CALCULATE: "Calculate" >
| < CASE: "case" >
| < CATCH: "catch" >
//| < CHAR: "char" >
//| < CLASS: "class" >
| < CONST: "const" >
| < CONTINUE: "continue" >
| < _DEFAULT: "default" >
| < DO: "do" >
//| < DOUBLE: "double" >
| < ELSE: "else" >
| < EXTENDS: "extends" >
| < FALSE: "false" >
| < FINAL: "final" >
| < FINALLY: "finally" >
//| < FLOAT: "float" >
| < FOR: "for" >
| < GOTO: "goto" >
| < IF: "if" >
| <PLUSSTR: "plus">
| < IMPLEMENTS: "implements" >
| < IMPORT: "import" >
| < INSTANCEOF: "instanceof" >
//| < INT: "int" >
| < INTERFACE: "interface" >
//| < LONG: "long" >
| < NATIVE: "native" >
| < NEW: "new" >
| < NULL: "null" >
| < PACKAGE: "package">
| < PRIVATE: "private" >
| < PROTECTED: "protected" >
| < PUBLIC: "public" >
| < RETURN: "return" >
//| < SHORT: "short" >
| < STATIC: "static" >
| < SUPER: "super" >
| < SWITCH: "switch" >
| < SYNCHRONIZED: "synchronized" >
//| < THIS: "this" >
| < THROW: "throw" >
| < THROWS: "throws" >
| < TRANSIENT: "transient" >
| < TRUE: "true" >
| < TRY: "try" >
| < VOID: "void" >
| < VOLATILE: "volatile" >
| < WHILE: "while" >
}

/* EXTENDED RESERVED WORDS */

TOKEN :
{
  < OF: "of" >
| < THE: "the" >
| < WHERE: "where" >
| < IS: "is" >
| < LESS: "less" >
| < THAN: "than" >

}


/* SEPARATORS */

TOKEN :
{
  < LPAREN: "(" >
| < RPAREN: ")" >
| < LBRACE: "{" >
| < RBRACE: "}" >
| < LBRACKET: "[" >
| < RBRACKET: "]" >
| < SEMICOLON: ";" >
| < COMMA: "," >
| < DOT: "." >
| < DDOT: ".." >
| < TDOT: "..." >
}

/* OPERATORS */

TOKEN :
{
  < ASSIGN: "=" >
| < GT: ">" >
| < LT: "<" >
| < BANG: "!" >
| < TILDE: "~" >
| < HOOK: "?" >
| < COLON: ":" >
//| < DOLLAR: "$" >
| < EQ: "==" >
| < LE: "<=" >
| < GE: ">=" >
| < NE: "!=" >
| < BOOL_OR: "||" >
| < BOOL_AND: "&&" >
| < INCR: "++" >
| < DECR: "--" >
| < PLUS: "+" >
| < MINUS: "-" >
| < STAR: "*" >
| < SLASH: "/" >
| < BIT_AND: "&" >
| < BIT_OR: "|" >
| < BIT_XOR: "^" >
| < REM: "%" >
| < LSHIFT: "<<" >
| < RSIGNEDSHIFT: ">>" >
| < RUNSIGNEDSHIFT: ">>>" >
| < PLUSASSIGN: "+=" >
| < MINUSASSIGN: "-=" >
| < STARASSIGN: "*=" >
| < SLASHASSIGN: "/=" >
| < ANDASSIGN: "&=" >
| < ORASSIGN: "|=" >
| < XORASSIGN: "^=" >
| < REMASSIGN: "%=" >
| < LSHIFTASSIGN: "<<=" >
| < RSIGNEDSHIFTASSIGN: ">>=" >
| < RUNSIGNEDSHIFTASSIGN: ">>>=" >

| < EXP: "**" >
| < IMPL: "->" >
}

/* JAVA LITERALS */

TOKEN :
{
  < INTEGER_LITERAL:
      //(["-","+"])? <DECIMAL_LITERAL> (["l","L"])?
       <DECIMAL_LITERAL> (["l","L"])?
      | <HEX_LITERAL> (["l","L"])?
      | <OCTAL_LITERAL> (["l","L"])?
  >
|
  < #DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* >
|
  < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
|
  < #OCTAL_LITERAL: "0" (["0"-"7"])* >
|
  < #FP_LITERAL1: (["0"-"9"])+ ("." (["0"-"9"])+ )? >
|
  < #FP_LITERAL2: ["1"-"9"] (["0"-"9"])? (["0"-"9"])? ("," ["0"-"9"] ["0"-"9"] ["0"-"9"])+ ("." (["0"-"9"])+ )? >
|
  < FLOATING_POINT_LITERAL:
//      (["-","+"])?
      (  (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f","F","d","D"])?
      | "." (["0"-"9"])+ (<EXPONENT>)? (["f","F","d","D"])?
      | (["0"-"9"])+ <EXPONENT> (["f","F","d","D"])?
      | (["0"-"9"])+ (<EXPONENT>)? ["f","F","d","D"])
  >
|
  < BUSINESS_INTEGER_LITERAL:
  	("$")?	<FP_LITERAL1>  (["M","K", "B"])?
  	|
  	("$")?	<FP_LITERAL2>  (["M","K", "B"])?
  				
  >

|
	<PERCENT_LITERAL:
	
	 	(["0"-"9"])+ ("." ["0"-"9"] ["0"-"9"] )? "%"		
	>
  		
	  
|
  < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
|
  < CHARACTER_LITERAL:
      "'"
      (   (~["'","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )
      "'"
  >
|
  < STRING_LITERAL:
      "\""
      (   (~["\"","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            | "u" (["0"-"9"]|["a"-"f"]) (["0"-"9"]|["a"-"f"])(["0"-"9"]|["a"-"f"])(["0"-"9"]|["a"-"f"]) 
            )
          )
      )*
      "\""
  >
}

/* IDENTIFIERS */

TOKEN :
{
  < IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>)* >
|
  < #LETTER:
      [
       "\u0024",
       "\u0041"-"\u005a",
       "\u005f",
       "\u0061"-"\u007a",
       "\u00c0"-"\u00d6",
       "\u00d8"-"\u00f6",
       "\u00f8"-"\u00ff",
       "\u0100"-"\u1fff",
       "\u3040"-"\u318f",
       "\u3300"-"\u337f",
       "\u3400"-"\u3d2d",
       "\u4e00"-"\u9fff",
       "\uf900"-"\ufaff"
      ]
  >
|
  < #DIGIT:
      [
       "\u0030"-"\u0039",
       "\u0660"-"\u0669",
       "\u06f0"-"\u06f9",
       "\u0966"-"\u096f",
       "\u09e6"-"\u09ef",
       "\u0a66"-"\u0a6f",
       "\u0ae6"-"\u0aef",
       "\u0b66"-"\u0b6f",
       "\u0be7"-"\u0bef",
       "\u0c66"-"\u0c6f",
       "\u0ce6"-"\u0cef",
       "\u0d66"-"\u0d6f",
       "\u0e50"-"\u0e59",
       "\u0ed0"-"\u0ed9",
       "\u1040"-"\u1049"
      ]
  >
}


TOKEN :
{
  < LABEL: <IDENTIFIER> <COLON> >
}



/* COMMENTS */

MORE :
{
//  "//" : IN_SINGLE_LINE_COMMENT
//|
  <"/**" ~["/"]> { input_stream.backup(1); } : IN_FORMAL_COMMENT
|
  "/*" : IN_MULTI_LINE_COMMENT
}

//<IN_SINGLE_LINE_COMMENT>
//SPECIAL_TOKEN :
//{
//  <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n" > : DEFAULT
//}

SPECIAL_TOKEN:
{
   < SINGLE_LINE_COMMENT : "//" (~["\n", "\r"])* ("\n" | "\r" | "\r\n")? >
}


<IN_FORMAL_COMMENT>
SPECIAL_TOKEN :
{
  <FORMAL_COMMENT: "*/" > : DEFAULT
}

<IN_MULTI_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <MULTI_LINE_COMMENT: "*/" > : DEFAULT
}

//<IN_SINGLE_LINE_COMMENT,IN_FORMAL_COMMENT,IN_MULTI_LINE_COMMENT>
<IN_FORMAL_COMMENT,IN_MULTI_LINE_COMMENT>
MORE :
{
  < ~[] >
}

/*
 * Expression syntax follows.
 */

void Expression() :
{
	Token x;
	String func = null;
}
{
	
	
  ConditionalTernaryExpression()
  [


      ( x = "=" {func="op.assign";}
      | x = "+=" {func="op.assign.add";} 
      | x = "-=" {func="op.assign.subtract";}
      | x = "*=" {func="op.assign.multiply";} 
      | x = "/=" {func="op.assign.divide";}
      | x = "&=" {func="op.assign.bitand";}
      | x = "|=" {func="op.assign.bitor";}
      | x = "^=" {func="op.assign.bitnot";}
      | x = "%=" {func="op.assign.rem";} 
    )
    Expression()
    {
      stb.bop(func, pos(x));
    }
  ]
}


void ConditionalTernaryExpression() :
{Token x;}
{
  ConditionalImplExpression()
  [ x="?" ConditionalTernaryExpression() ":" ConditionalTernaryExpression()
    { stb.nop("op.ternary.qmark", pos(x), 3); }
  ]
}

void ConditionalImplExpression() :
{Token x;}
{
  ConditionalOrExpression()
  (
    LOOKAHEAD( <IMPL> )
    (x = <IMPL>) ConditionalOrExpression() 
    { stb.bop("op.binary.impl", pos(x)); }
  )*
}

void ConditionalOrExpression() :
{Token x;}
{
  ConditionalAndExpression() ( (x=<BOOL_OR> | x = "or") ConditionalAndExpression() 
  { stb.bop("op.binary.or", pos(x)); } )*
}


void ConditionalAndExpression() :
{Token x;}
{
  BitwiseOrExpression() 
  ( (x=<BOOL_AND>| x = "and") BitwiseOrExpression()  
  { stb.bop("op.binary.and", pos(x)); } )*
}



void BitwiseOrExpression() :
{Token x;}
{
  BitwiseXorExpression() (LOOKAHEAD(2) (x=<BIT_OR>) BitwiseXorExpression() 
  { stb.bop("op.binary.bitor", pos(x)); } )*
}

void BitwiseXorExpression() :
{Token x;}
{
  BitwiseAndExpression() ( 
  x=<BIT_XOR> BitwiseAndExpression() 
  { stb.bop("op.binary.bitxor", pos(x)); } )*
}

void BitwiseAndExpression() :
{Token x;}
{
  EqualityExpression() 
  ( (x=<BIT_AND>) EqualityExpression()  
  { stb.bop("op.binary.bitand", pos(x)); } )*
}



void EqualityExpression() :
{
 Token x;
 String func = null;
}
{
  RelationalExpression()
  (
    ( (x = <EQ> | x = "equals to" | x = "is same as"){func="eq";} | (x = <NE> | x = "does not equal to" | x = "is different from"){func="ne";})
    RelationalExpression()
    {stb.bop("op.binary." + func, pos(x));}
  )*
}

void OfTheExpression() :
{
 Token x;
}
{
  Expression()
  (
    ( x = <OF>    <THE>)
    Expression()
    {stb.bop("of.the" , pos(x));}
  )
}


void RelationalExpression() :
{
	Token x;
	String func = null;
}
{
  ShiftExpression()
  (
    ( x = <LT> {func="lt";} | x = "is less than" {func="lt";} | 
    x = <GT> {func="gt";} | x = "is more than" {func="gt";} |
    x = <LE>{func="le";} | x = "is less or equal" {func="le";} | x = "is no more than" {func="le";} | x = "is in" {func="le";} | 
    x = <GE>{func="ge";} | x = "is more or equal" {func="ge";} | x = "is no less than" {func="ge";} 
    
    )
    ShiftExpression()
    {
    	{stb.bop("op.binary." + func, pos(x));}
    }
  )*
}


void ShiftExpression() :
{
Token x;
String func = null;
}
{
  AdditiveExpression()
  (
    (x=<LSHIFT> {func="lshift";}| x=<RSIGNEDSHIFT> {func="rshift";} | x=<RUNSIGNEDSHIFT> {func="rshiftu";})
    AdditiveExpression()
    {stb.bop("op.binary." + func, pos(x));}
  )*
}


void AdditiveExpression() :
{
Token x;
String func = null;
}
{
  MultiplicativeExpression()
  (
    (x=<PLUS> {func="add";}| x=<PLUSSTR> {func="add";} | x=<MINUS> {func="subtract";})
    MultiplicativeExpression()
    {stb.bop("op.binary." + func, pos(x));}
  )*
}

void MultiplicativeExpression() :
{
Token x;
String func = null;
}
{
  PowerExpression()
  (
    ( x = <STAR>{func="multiply";} | x = <SLASH> {func="divide";}| x = <REM> {func="rem";})
    PowerExpression()
    {stb.bop("op.binary." + func, pos(x));}
  )*
}

void PowerExpression() :
{Token x;}
{
  UnaryExpression()
  (
    LOOKAHEAD( <EXP> )
    x=<EXP> UnaryExpression()
    {stb.bop("op.binary.pow", pos(x));}
  )*
}

void UnaryExpression() :
{Token x;}
{
	

  x=<PLUS> UnaryExpression()     
  {stb.uop("op.unary.positive", pos(x));}

|
  x=<MINUS> UnaryExpression() 
  {stb.uop("op.unary.negative", pos(x));}
|
  x=<TILDE> UnaryExpression() 
  {stb.uop("op.unary.bitnot", pos(x));}
|
  x=<BANG> UnaryExpression() 
  {stb.uop("op.unary.not", pos(x));}
|
  PreIncrementExpression()
|
  PreDecrementExpression()
|
  LOOKAHEAD( CastLookahead() )
  CastExpression()
|
  PostfixExpression()
}

void PreIncrementExpression() :
{Token x;}
{
  x="++" PrimaryExpression() 
  { stb.uop("op.prefix.inc", pos(x)); }
}

void OfTheExpressionSuffix() :
{Token x;}
{
  x=<OF> <THE> PrimaryExpression() {stb.bop("chain.suffix.of.the",null);}
}


void PreDecrementExpression() :
{Token x;}
{
  x="--" PrimaryExpression() { stb.uop("op.prefix.dec", pos(x)); }
}

void PostfixExpression() :
{Token x;}
{
  PrimaryExpression() 
  [ x="++"  
	  { stb.uop("op.suffix.inc", pos(x)); }
   | x="--"  
	  { stb.uop("op.suffix.dec", pos(x)); }
  ]
}

//void PrimaryExpression() :
//{
//  int args = 1;
//  String func = "standard";
//}
//{
//	
//  PrimaryPrefix() ( LOOKAHEAD(2) PrimarySuffix() {++args;} )* 
//  {
//  	if (args > 1)
//  		stb.nop("chain", null, args);
//  }
//  
//  
//}



void PrimaryExpression() :
{
  int args = 1;
}
{
	
  PrimaryPrefix() ( LOOKAHEAD(2) PrimarySuffix() {++args;} )* 
  {
  	if (args > 1)
  		stb.uop("chain", null);
  }
  
  
}





void PrimaryPrefix() :
{}
{
	
 CommaSeparatedList()
|  
  Literal()
|
  AbsExpression()
|
  "(" Expression() ")"
|
  AllocationExpression()
//|
//  LOOKAHEAD( ResultType() "." "class" )
//  ResultType() "." "class"
//  { stb.identifier("ident", token.image); stb.nop(".chain",2); }


|
 LOOKAHEAD( function() ) function()

|
LOOKAHEAD(2) 

FilterExpression() IdentifierSequence() 

  
|
IdentifierSequence()
//|	
//	
  
  
//|
//  identifier()

//| BlockClosure()
}

//void IdentifierChain() :
//{Token x1;}
//{
// 	
//  IdentifierSequence()
//  (x1="of the" IdentifierSequence())*
//}


//void IdentifierSequence() :
//{Token x1; int args = 2;}
//{
//  (x1 = <IDENTIFIER> {stb.identifier("identifier.sequence.element", pos(token),token.image);})
//  (x1 = <IDENTIFIER> {stb.identifier("identifier.sequence.element", pos(token),token.image);})
//  (x1 = <IDENTIFIER> {stb.identifier("identifier.sequence.element", pos(token),token.image); ++args;})*
//  {
//    	if (args > 1)
//  		   stb.nop("identifier.sequence", null, args);
//  }		
//  
//}

void IdentifierSequence() :
{Token x1; int args = 1;}
{
  (x1 = <IDENTIFIER> {stb.identifier("identifier", pos(token),token.image);})
  (x1 = <IDENTIFIER> {stb.identifier("identifier.sequence.element", pos(token),token.image); ++args;})*
  {
    	if (args > 1)
  		   stb.nop("identifier.sequence", null, args);
  }		
  
}


void FilterExpression() :
{Token x1; int args = 1;}
{
	SimpleFilter() ("or" | "and") FilterExpression()
	|
	SimpleNotFilter() (("or" | "and") (SimpleFilter() | SimpleNotFilter()))*  
}

void SimpleFilter() :
{}
{
	Word("identifier.filter")
}


void SimpleNotFilter() :
{}
{
	"not" Word("identifier.filter.not")
}


void Word(String type) :
{Token x1;}
{
  (x1 = <IDENTIFIER> {stb.identifier(type, pos(token),token.image);})
  
}


//void IdentifierSequence(int limit) :
//{Token x1; int args = 2;}
//{
//  (x1 = <IDENTIFIER> {stb.identifier("identifier.sequence.element", pos(token),token.image);})
//  (x1 = <IDENTIFIER> {stb.identifier("identifier.sequence.element", pos(token),token.image); ++args;})*
//  {
//    	if (args > 1)
//  		   stb.nop("identifier.sequence", null, args);
//  }		
//  
//}


void PrimarySuffix() :
{Token x1;}
{
  IndexOperator() {stb.bop("chain.suffix.dot.index", null);}
  | LOOKAHEAD( "." function() ) "." function() {stb.bop("chain.suffix.dot.function", null);}
 // | "of the" PrimaryExpression()
  | OfTheExpressionSuffix()
  | "." identifier() {stb.bop("chain.suffix.dot.identifier", null);}
  
//  | x1 = <IDENTIFIER> {stb.identifier("identifier.chain", pos(token),token.image);}
}

void CastExpression() :
{Token x1, x2;}
{
  x1="(" Type() x2=")" UnaryExpression() 
  { stb.bop("type.cast", pos(x1,x2)); }
}

void CastLookahead() :
{}
{
  "(" Type() ")" ( "~" | "!" | "(" | "[" | <IDENTIFIER> | "new" | Literal() )
}

void identifier() :
{}
{
  <IDENTIFIER>
  {
    stb.identifier("identifier", pos(token),token.image);
  }
}

void TypeDimension() :
{Token x1, x2;}
{
  x1="[" x2="]"  
  { 
  	stb.uop("type.index", pos(x1, x2)); 
  }
}

void Type() :
{
}
{
//  ( PrimitiveType() | ClassName() ) ( TypeDimension() )*
  ClassName() ( TypeDimension()  )*
  {stb.uop("type.declaration", null);}
}


void ResultType() :
{}
{
  "void"      
  { 
     stb.identifier("type.name",pos(token),token.image);
	 stb.uop("type.declaration", null);   
}
|
  Type()
}

void ClassName() :
{
  String name;
  Token x1, x2;
}
{
  x1=<IDENTIFIER>  {name = token.image; x2=x1;}
  ( LOOKAHEAD(2) "." x2=<IDENTIFIER>  {name = name + "." + token.image;}
  )*
  { stb.identifier("type.name",pos(x1, x2),name); }
}


void CommaSeparatedList() :
{
	int elements = 0;
	int words = 0;
}
{
	"[" 
	{words = 0;} 
	( 
		 
	    Word("identifier.list") {++words;})+     
		{stb.nop("list.element", null, words); ++elements;}
	 
	("," {words =0;}
	(
	 	Word("identifier.list"){++words;})+ 
		{stb.nop("list.element", null, words); ++elements;})* "]"
	
	{stb.nop("list", null, elements);}
}

void function() :
{
  String funcname;
  int args = 0;
  Token x1, x2;
}
{
  x1=<IDENTIFIER> {funcname = token.image;}
  "("
  [ Expression() {args++;} ( "," Expression() {args++;})* ]
  x2=")"
  {
  	stb.identifier("funcname", pos(x1), funcname);
    stb.nop("function", pos(x1,x2), args + 1);
  }

}

void AllocationExpression() :
{
  int args = 0;
  Token x1, x2;
}
{
  x1="new" ClassName()
  (
    "("
    [ Expression() {args++;} ( "," Expression() {args++;})* ]
    x2=")"
    {
      stb.nop("op.new.object",pos(x1, x2), args + 1);
    }

    |

    ArrayDimsAndInits()
    {
      stb.uop("op.new.array",pos(x1));
    }
  )

}

/*
 * The second LOOKAHEAD specification below is to parse to PrimarySuffix
 * if there is an expression between the "[...]".
 */
void ArrayDimsAndInits() :
{
	Token x1, x2;
	int cnt = 0; 
}
{
  LOOKAHEAD(2)
  ( LOOKAHEAD(2) x1="[" Expression() x2="]" {stb.bop("array.index.expression", pos(x1, x2)); cnt++;} )+
  ( LOOKAHEAD(2) x1="[" x2="]" {stb.uop("array.index.empty", pos(x1, x2));} )*
|
  ( TypeDimension() )+ ArrayInitializer()
}


void IndexOperator() :
{Token x1,x2;}
{
  x1="["
    Expression()
  x2="]"
  {
    stb.uop("op.index", pos(x1, x2));
    
  }

}

void AbsExpression() :
{Token x1, x2;}
{
  x1="|" Expression() x2="|"
  {
    stb.uop("op.unary.abs", pos(x1,x2));
  }
}



void Literal() :
{}
{
  <INTEGER_LITERAL>         
  { stb.literal("literal.integer", pos(token), token.image); }
  |
//  LOOKAHEAD(LiteralBI() "-")//  RangeLiteralBinary()//  |
  <BUSINESS_INTEGER_LITERAL>         
  { stb.literal("literal.integer.business", pos(token), token.image); }
  |
  <PERCENT_LITERAL>         
  { stb.literal("literal.percent", pos(token), token.image); }
  |
  <FLOATING_POINT_LITERAL>  
  { stb.literal("literal.real", pos(token), token.image); }
  |
  <STRING_LITERAL>          
  { stb.literal("literal.string", pos(token), token.image); }
  |
  <CHARACTER_LITERAL>       
  { stb.literal("literal.char", pos(token), token.image); }
  |
  BooleanLiteral()
  |
  NullLiteral()
}

void LiteralBI() :
{}
{
  <INTEGER_LITERAL>         
  { stb.literal("literal.integer", pos(token), token.image); }
  |
  <BUSINESS_INTEGER_LITERAL>         
  { stb.literal("literal.integer.business", pos(token), token.image); }
}

void LiteralFloat() :
{}
{
  (<FLOATING_POINT_LITERAL> | <INTEGER_LITERAL>)        
  { stb.literal("literal.real", pos(token), token.image); }
  |
  <BUSINESS_INTEGER_LITERAL>
  { stb.literal("literal.real.business", pos(token), token.image); }
}

void RangeBinary():
{
	Token x; 
	String op; 
}
{
	LiteralBI()
	(x=<MINUS> {op="minus";} | x =<DDOT> {op="ddot";} | x=<TDOT>{op="tdot";} )
	LiteralBI()
	{stb.bop("literal.range.binary." + op, pos(x));}
}

void RangeNumber():
{
}
{
	LiteralBI()
	{stb.uop("literal.range.number", null);}
}


void RangePrefix():
{
	Token x;
	String op; 
}
{
	(x="<" {op="lt";} | x = "<=" {op="le";} | x = ">" {op="gt";} | x =">=" {op="ge";})
	LiteralBI()
	{stb.uop("literal.range.unary.prefix." + op, pos(x));}	
}

void RangeSuffix():
{
	Token x;
	String op; 
}
{
	LiteralBI()
	(x="<" {op="lt";} | x = "<=" {op="le";} | x = ">" {op="gt";} | x =">=" {op="ge";} | x ="+" {op="plus";})
	{stb.uop("literal.range.unary.suffix."+op, pos(x));}
}


void RangeLiteral() :
{
	Token x; 
	String op;
}
{
	(
	LOOKAHEAD(RangeBinary())
	RangeBinary()
	|
	LOOKAHEAD(RangePrefix())
	RangePrefix()
	| 
	LOOKAHEAD(RangeSuffix())
	RangeSuffix()
	| 
	RangeNumber()
	)
	<EOF>
}
void RangeBinaryFloat():
{
	Token x; 
	String op; 
}
{
	LiteralFloat()
	(x=<MINUS> {op="minus";}| x =<DDOT> {op="ddot";} | x=<TDOT>{op="tdot";} )
	LiteralFloat()
	{stb.bop("literal.range.binary." + op, pos(x));}
}

void RangeNumberFloat():
{
}
{
	LiteralFloat()
	{stb.uop("literal.range.number", null);}
}


void RangePrefixFloat():
{
	Token x;
	String op; 
}
{
	(x="<" {op="lt";} | x = "<=" {op="le";} | x = ">" {op="gt";} | x =">=" {op="ge";})
	LiteralFloat()
	{stb.uop("literal.range.unary.prefix." + op, pos(x));}	
}

void RangeSuffixFloat():
{
	Token x;
	String op; 
}
{
	LiteralFloat()
	(x="<" {op="lt";} | x = "<=" {op="le";} | x = ">" {op="gt";} | x =">=" {op="ge";} | x ="+" {op="plus";})
	{stb.uop("literal.range.unary.suffix."+op, pos(x));}
}

void RangeLiteralFloat() :
{
	Token x; 
	String op;
}
{
	(
	LOOKAHEAD(RangeBinaryFloat())
	RangeBinaryFloat()
	|
	LOOKAHEAD(RangePrefixFloat())
	RangePrefixFloat()
	| 
	LOOKAHEAD(RangeSuffixFloat())
	RangeSuffixFloat()
	| 
	RangeNumberFloat()
	)
	<EOF>
}

void BooleanLiteral() :
{}
{
  <TRUE>              
  {stb.literal("literal.bool", pos(token), token.image);}
  |
  <FALSE>             
  {stb.literal("literal.bool", pos(token), token.image);}
}

void NullLiteral() :
{}
{
  <NULL>              
  {stb.literal("literal.null", pos(token), token.image);}
}

void Block() :
{Token x1, x2;}
{
  x1="{"
  BlockStatementList()
  x2="}"
  { 
  //stb.uop("{}", pos(x1, x2)); 
  }

}

void BlockStatementList() :
{
  int args = 0;
}
{
  ( BlockStatement() {args++;} )*
  {
    stb.nop("block.statement", null, args);
  }

}

void OptionalSemiColon() :
{}
{
  (<SEMICOLON> | <EOF>)
}

void SemiColon() :
{}
{
  <SEMICOLON> 
}


void Statement() :
{}
{
  LOOKAHEAD(2)
  LabeledStatement()
|
  Block()
|
  EmptyStatement()
//|
//   LOOKAHEAD(2) ExtendedWhereStatement() 	  
|
  StatementExpression() OptionalSemiColon()
|
  IfStatement()
|
  WhileStatement()
|
  DoStatement()
|
  ForStatement()
|
  BreakStatement()
|
  ContinueStatement()
|
  ReturnStatement()
|
  ThrowStatement()

}



void ExtendedWhereStatement():
{
	int args = 1;	
}
{
	//(<IDENTIFIER> ":=" | "Calculate") Expression()
	
	 "," "where" WhereVarExpalnation() (LOOKAHEAD(2) "," WhereVarExpalnation() {++args;})*
	 
	 {stb.nop("where.explanation", null, args);} 
}


void WhereVarExpalnation():
{}
{
	Word("identifier.var.explanation") "-" Expression()
	{
		stb.bop("where.var.expalnation", null);
	}
}


void LabeledStatement() :
{
  String label;
}
{
  <IDENTIFIER> {label = token.image; } ":"
  { stb.notImplemented("startLabel(label)"); }
  Statement()
  { stb.notImplemented("endLabel()"); }
}

void BlockStatement() :
{}
{
  LOOKAHEAD(Type() <IDENTIFIER> "=")
  LocalVariableDeclaration() SemiColon()
|
  LOOKAHEAD(Type() <IDENTIFIER> ";")
  LocalVariableDeclaration() SemiColon()
|
  LOOKAHEAD(Type() <IDENTIFIER> ",")
  LocalVariableDeclaration() SemiColon()
|
  Statement()
}

void StatementExpression() :
{}
{
  Expression() [LOOKAHEAD(2) ExtendedWhereStatement()  {stb.bop("where.expression", null);}]
}

void EmptyStatement() :
{}
{
  <SEMICOLON> 
  { stb.emptyStatement(token.image, pos(token)); }
}

void IfStatement() :
{
  Token x1;	
  int nodes = 2;
}
{
  x1=<IF> "(" Expression() ")" Statement()
  [ LOOKAHEAD(1) <ELSE> Statement()  { ++nodes; }]
  { stb.nop("control.if", pos(x1), nodes ); }
}

void WhileStatement() :
{
	Token x;
}
{
//  { stb.notImplemented("startLabel(null)"); } // anonymous label for cycles
  x="while" "(" Expression() ")" Statement() { stb.bop("control.while", pos(x)); }
//  { stb.notImplemented("endLabel()"); }
}


void ReturnStatement() :
{
  int args = 0;
  Token x;
}
{
  x = "return" [ Expression() {++args;} ] ";"
  {stb.nop("control.return", pos(x), args);}
}

void ThrowStatement() :
{}
{
  "throw" Expression() ";"
}



void DoStatement() :
{}
{
  { stb.notImplemented("startLabel(null)"); } // anonymous label for cycles
  "do" Statement() "while" "(" Expression() ")" OptionalSemiColon() { stb.notImplemented("doStatement()"); }
  { stb.notImplemented("endLabel()"); }
}

void LocalVariableDeclaration() :
{
  int args = 0;
}
{
  Type() VariableDeclarator() {args++;} ( "," VariableDeclarator() {args++;})*
  {
    stb.nop("local.var.declaration", null, args + 1);
  }
}

void VariableDeclarator() :
{
  boolean withInitializer = false;
}
{
  VariableDeclaratorId() [ "=" VariableInitializer() {withInitializer=true;} ]
  {
  	if (withInitializer)
  	{
  	  stb.bop("local.var.name.init", null);	
  	}
  	else
  	{
//  	  stb.uop("local.name.noinit", pos(x));	
  	} 
//  	stb.notImplemented("varDeclarator(withInitializer)"); 
  }
}

void VariableDeclaratorId() :
{}
{
  identifier() ( TypeDimension() )*
}

void VariableInitializer() :
{}
{
  ArrayInitializer()
|
  Expression()
}

void ArrayInitializer() :
{
  int args = 0;
  Token x1, x2;
}
{
  x1 ="{"
    [ VariableInitializer() {args++;}
      ( LOOKAHEAD(2) "," VariableInitializer() {args++;} )*
    ]
    [ "," ]
  x2 ="}"
  { stb.nop("array.init", pos(x1, x2),args); }
}

void ForStatement() :
{
  boolean[] bParts = new boolean[4];
  Token x;
}
{
  { 
  //!!!stb.notImplemented("startLabel(null)"); 
  } // anonymous label for cycles
  x = "for" "("
    [ ForInit()     {bParts[0] = true;} ] <SEMICOLON>
    [ Expression()  {bParts[1] = true;} ] <SEMICOLON>
    [ ForUpdate()   {bParts[2] = true;} ]
  ")" Statement() {bParts[3] = true;}
  { 
  	stb.nop("control.for", pos(x) ,bParts); 
  }
  { 
	  //!!!stb.notImplemented("endLabel()"); 
  }
}

void ForInit() :
{}
{
  LOOKAHEAD( Type() <IDENTIFIER> )
  LocalVariableDeclaration()
|
  StatementExpressionList()
}

void StatementExpressionList() :
{
  int args = 0;
}
{
  StatementExpression() {args++;} ( "," StatementExpression() {args++;} )*
  {
  	if (args > 1)
    	stb.nop("statement_list",null, args);
  }

}

void ForUpdate() :
{}
{
  StatementExpressionList()
}



void BreakStatement() :
{
  String label=null;
}
{
  "break" [ <IDENTIFIER> {label = token.image; } ] OptionalSemiColon()
  {stb.notImplemented("doBreak(label)");}
}

void ContinueStatement() :
{
  String label = null;
}
{
  "continue" [ <IDENTIFIER> {label = token.image; } ] OptionalSemiColon()
  {stb.notImplemented("doContinue(label)");}
}



void MethodHeader():
{}
{
  ( "public" | "protected" | "private" | "static" | "abstract" | "final" | "native" | "synchronized" )*
  ResultType() MethodDeclarator() 
  {stb.nop("method.header", null, 3);}
}


void MethodDeclaration() :
{}
{
//  ( "public" | "protected" | "private" | "static" | "abstract" | "final" | "native" | "synchronized" | "strictfp")*
  ( "public" | "protected" | "private" | "static" | "abstract" | "final" | "native" | "synchronized" )*
  ResultType() MethodDeclarator() 
  //[ "throws" NameList() ]
  ( Block()  {stb.nop("method.declaration", null, 4);} | ";" )
}

void MethodDeclarator() :
{}
{
  MethodName() FormalParameters() //( "[" "]" )*
}

void MethodName() :
{}
{
  identifier()
}

void FormalParameters() :
{
  int args = 0;
  Token x1, x2;
}
{
  x1 = "(" [ FormalParameter() {++args;} ( "," FormalParameter() {++args;} )* ]  x2=")"
  
  {stb.nop("method.parameters", pos(x1,x2), args);}
}

void FormalParameter() :
{
//	java.util.Map map = new java.util.HashMap();			
}
{
// [ "final" {map.put("final", "final");} ] 
       Type() VariableDeclaratorId() 
//   [
//    "in" {map.put("in", "in");} 
//    | 
//    "out" {map.put("out", "out");} 
//    | 
//    "inout" {map.put("inout", "inout");}
//    ]
  
  {
    stb.nop("parameter.declaration", null, 2);
  }
  
}

void VarDeclaration() :
{
}
{
  LocalVariableDeclaration() ";"
  {stb.uop("var.declaration", null);}
}  

void MethodOrVarDeclaration() :
{
}
{
   LOOKAHEAD(ResultType() MethodDeclarator())	
   MethodDeclaration()
   |
   VarDeclaration()
}





void parseModuleInternal() :
{
  int nMethods = 1;
}
{
//   MethodDeclaration() (MethodDeclaration()  {++nMethods;})*
   MethodOrVarDeclaration() (MethodOrVarDeclaration()  {++nMethods;})*
  { if (nMethods > 0) stb.nop("module.top", null, nMethods); }
  <EOF>
}




/*
*/

void parseTopNodeInternal() :
{}
{
  BlockStatementList()
  { stb.uop("block.top", null); }
//  parseMethodsInternal()
  <EOF>
}


//void ParameterDeclaration() :
//{
//  int args = 0;
//}
//{
//  [ Type() {args++;} ] ":" identifier()
//  {
//    _ipr.parameterDeclaration(args);
//  }
//}
//
//void ParameterDeclarations() :
//{
//  int args = 0;
//}
//{
//  ParameterDeclaration() {args++;} ( "," ParameterDeclaration()  {args++;} )*
//  { _ipr.parameterDeclarations(args); }
//}
//
//
//void BlockClosure() :
//{
//  int args = 0;
//}
//{
//  "["
//  [ LOOKAHEAD(ParameterDeclaration()) ParameterDeclarations() "|" { args++; } ]
//  BlockStatementList()
//  "]"
//  { _ipr.blockClosure(args); }
//
//}
//
