package org.openl.studio.security.pat.model;

import java.util.Objects;
import jakarta.validation.constraints.NotBlank;

/**
 * Structured representation of a Personal Access Token (PAT) value.
 * Consists of a public identifier and a secret part.
 */
public record PatToken(
        @NotBlank
        String publicId,

        @NotBlank
        String secret
) {

    public static final String PREFIX = "openl_pat_";
    private static final char SEPARATOR = '.';
    private static final int MAX_TOKEN_LENGTH = 256; // Prevent DoS attacks
    public static final int PUBLIC_ID_LENGTH = 16; // Generated by Base62Generator
    public static final int SECRET_LENGTH = 32; // Generated by Base62Generator
    private static final String BASE62_PATTERN = "^[0-9a-zA-Z]+$"; // Base62 character set

    /**
     * Parse PAT token string into structured value.
     * <p>
     * <strong>Security Note:</strong> This method validates the token format, length, and character set
     * to prevent injection attacks and DoS vulnerabilities. Only Base62 alphanumeric characters
     * are allowed in publicId and secret components.
     * </p>
     *
     * @param token raw token value (e.g. openl_pat_xxx.yyy)
     * @return parsed PersonalAccessTokenValue
     * @throws IllegalArgumentException if format is invalid, too long, or contains invalid characters
     */
    public static PatToken parse(String token) {
        Objects.requireNonNull(token, "token must not be null");

        // Prevent DoS attacks with excessively long tokens
        if (token.length() > MAX_TOKEN_LENGTH || !token.startsWith(PREFIX)) {
            throw new IllegalArgumentException("Invalid PAT token format");
        }

        int dotIndex = token.indexOf(SEPARATOR, PREFIX.length());
        if (dotIndex < 0) {
            throw new IllegalArgumentException("Invalid PAT token format");
        }

        String publicId = token.substring(PREFIX.length(), dotIndex);
        String secret = token.substring(dotIndex + 1);

        if (!isValidPublicId(publicId)) {
            throw new IllegalArgumentException("Invalid PAT token format");
        }
        if (!isValidSecret(secret)) {
            throw new IllegalArgumentException("Invalid PAT token format");
        }

        return new PatToken(publicId, secret);
    }

    public static boolean isValidPublicId(String publicId) {
        if (publicId == null || publicId.length() != PUBLIC_ID_LENGTH) {
            return false;
        }
        return publicId.matches(BASE62_PATTERN);
    }

    private static boolean isValidSecret(String secret) {
        if (secret == null || secret.length() != SECRET_LENGTH) {
            return false;
        }
        return secret.matches(BASE62_PATTERN);
    }

    /**
     * Create PAT token string from components.
     */
    public String asTokenValue() {
        return PREFIX + publicId + SEPARATOR + secret;
    }
}
